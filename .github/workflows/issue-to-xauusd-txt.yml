name: Issue -> orders/xauusd.txt

on:
  issues:
    types: [opened, edited, labeled, reopened]

permissions:
  contents: write
  issues: read

concurrency:
  group: issue-to-orders-xauusd
  cancel-in-progress: true

jobs:
  write-order-file:
    # ラベルが両方付いている Issue だけ実行
    if: >
      contains(github.event.issue.labels.*.name, 'order') &&
      contains(github.event.issue.labels.*.name, 'xauusd')
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build orders/xauusd.txt from Issue body
        env:
          ISSUE_BODY: ${{ github.event.issue.body }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
        shell: bash
        run: |
          set -euo pipefail

          out="orders/xauusd.txt"
          mkdir -p "$(dirname "$out")"
          : > "$out"

          # --- 見出し(### ...) を key に変換 ---
          # Issueフォームの "label:" の文字列に合わせて case を調整してください。
          # 例: label を日本語にしている場合は日本語に合わせる。
          to_key() {
            local h="$1"
            # 余計な前後空白を除去
            h="$(echo "$h" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"

            case "$h" in
              "state") echo "state" ;;
              "command_id") echo "command_id" ;;
              "direction") echo "direction" ;;
              "watch_price") echo "watch_price" ;;
              "invalidate_price") echo "invalidate_price" ;;
              "bounce_points") echo "bounce_points" ;;
              "stop_points") echo "stop_points" ;;
              "lots") echo "lots" ;;
              "max_spread_points") echo "max_spread_points" ;;
              "pos_action") echo "pos_action" ;;
              "pos_sl") echo "pos_sl" ;;
              "pos_tp") echo "pos_tp" ;;
              # 使わない見出しは空で返す（＝出力しない）
              *) echo "" ;;
            esac
          }

          body="${ISSUE_BODY}"

          current=""
          while IFS= read -r line; do
            # 見出し行 "### xxx"
            if [[ "$line" =~ ^###[[:space:]](.+)$ ]]; then
              current="${BASH_REMATCH[1]}"
              continue
            fi

            # 見出しの次に来る値を拾う（空行はスキップして次へ）
            if [[ -n "$current" ]]; then
              val="$(echo "$line" | sed -e 's/\r$//' -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"

              # 空行は無視して次の行へ（値が現れるまで待つ）
              if [[ -z "$val" ]]; then
                continue
              fi

              # 未回答マーカーは捨てる（＝行を作らない）
              if [[ "$val" == "_No response_" ]]; then
                current=""
                continue
              fi

              key="$(to_key "$current")"
              if [[ -n "$key" ]]; then
                # 値に "###" が混ざる等の事故を軽減（必要ならここで更に整形）
                echo "${key}=${val}" >> "$out"
              fi

              current=""
            fi
          done <<< "$body"

          # 便利ログ
          echo "----- generated: $out -----"
          cat "$out" || true

      - name: Generate command_id (if missing)
        id: gen_cid
        shell: bash
        run: |
          set -euo pipefail

          # Issue metadata
          ISSUE_NO='${{ github.event.issue.number }}'
          UPDATED_AT='${{ github.event.issue.updated_at }}'

          # updated_at をUTCで yyyymmdd_hhmmss に
          TS_UTC="$(date -u -d "$UPDATED_AT" +%Y%m%d_%H%M%SZ)"
          # updated_at を epoch 秒に（編集のたびに変わる）
          EPOCH="$(date -u -d "$UPDATED_AT" +%s)"

          # 生成 command_id（例: 20251229_031500Z_I12_U1767006900）
          CID="${TS_UTC}_I${ISSUE_NO}_U${EPOCH}"

          echo "command_id=$CID" >> "$GITHUB_OUTPUT"

      - name: Commit & Push (if changed) with rebase + retry
        shell: bash
        run: |
          set -euo pipefail

          if git diff --quiet -- orders/xauusd.txt; then
            echo "No changes. Skip commit."
            exit 0
          fi

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add orders/xauusd.txt
          git commit -m "Update orders/xauusd.txt from Issue #${{ github.event.issue.number }}"

          # ここからが重要：リモートを取り込んで fast-forward 可能にする
          git fetch origin main

          # rebase でローカルcommitを最新mainの上に乗せる
          if ! git rebase origin/main; then
            echo "Rebase failed (conflict). Abort."
            git rebase --abort || true
            exit 1
          fi

          # push 失敗時のリトライ（同時更新に強くする）
          for i in 1 2 3 4 5; do
            if git push origin HEAD:main; then
              echo "Push success."
              exit 0
            fi
            echo "Push rejected. Refetch & rebase then retry... ($i/5)"
            git fetch origin main
            git rebase origin/main || (git rebase --abort || true; exit 1)
            sleep $((i*2))
          done

          echo "Push failed after retries."
          exit 1
